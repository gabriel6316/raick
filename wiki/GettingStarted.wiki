=<font color="#003366">Getting started with RAICK</font>=
==<font color="#006666">Installation</font>==
First things first, you need to let RAICK install itself. Unlike other AI scripts RAICK is packaged into a single file. This file contains all of the logic needed to create the initial folder and file structure.<br>
  * To install RAICK you first need to decide where to put it. A typical place for custom scripts is the `USER_AI` folder, but you are not limited to a specific place. Once you have decided where to put it you need to open your `AI.lua` or `AI_M.lua` file in either `AI` or `AI/USER_AI` folder(depending on what */hoai* setting you are planning to use) and put a single line of code there:
  <code language="lua">
require "./AI/USER_AI/RAICK.lua"
</code>
  This line of code assumes that you have put `RAICK.lua` to the `USER_AI` folder. The dot represents the folder of your Rangarok client. You could have also written the full path to RAICK:
  <code language="lua">
require "C:/Program Files/Gravity/Ragnarok/AI/USER_AI/RAICK.lua" -- Of course, you should put the actual path to your client if it is somewhere else
</code>
  And as i said you are not limited to your client folder only:
  <code language="lua">
require "C:/RAICK.lua"
</code>
  In this case all files and folders will be created right on the `C:/` disk.<br>
  * Once `RAICK.lua` is linked with the `AI.lua` or `AI_M.lua` file you'll just need to launch the script from the game(activate your homunculus/mercenary). For a moment you will see a command-prompt window, which will signal that the installation has been performed.

  * If a new version if RAICK is released then you just need to replace the `RAICK.lua` file and your RAICK is updated
  _Note: If you have been using the beta version then it is best if you replace `RAICK.lua` with the new file, run it and uninstall RAICK using the created uninstaller(the beta version didn't have one). After that install the script again._<br><br>
----
==<font color="#006666">Files & Folders</font>==
The schema below illustrates the full set of files that RAICK can create:
<pre>
-\
 |-\ "Homunculus Script"
   |-\ "Logs & Errors"
     |- "Error History.txt"
   |- "`[0]` Memory.lua"
   |- "`[1]` On Startup.lua"
   |- "`[2]` Commands.lua"
   |- "`[3]` Skills.lua"
   |- "`[4]` Messages.lua"
   |- "`[5]` Activities.lua"
 |-\ "Mercenary Script"
   |-\ "Logs & Errors"
     |- "Error History.txt"
   |- "`[0]` Memory.lua"
   |- "`[1]` On Startup.lua"
   |- "`[2]` Commands.lua"
   |- "`[3]` 1. Common Skills.lua"
   |- "`[3]` 2. Bowman Skills.lua"
   |- "`[3]` 3. Fencer Skills.lua"
   |- "`[3]` 4. Lancer Skills.lua"
   |- "`[4]` Messages.lua"
   |- "`[5]` Activities.lua"
 |- "RAICK.Bugz.txt
 |- "RAICK.lua"
 |- "RAICK.Settings.lua"
 |- "RAICK.Uninstaller.bat"
</pre>
Most of them are created during installation, others during runtime, when needed. You can see that homunculus and mercenary scripts are separated into different folders for easier management.<br><br>
===<font color="#006600">Common Files</font>===
  * <u>*RAICK.Bugz.txt* file</u>
  This file is created(and later updated) when RAICK encounters a bug inside itself. The entry will contain the time when the error occurep and a copy of the error window. This is possible, because RAICK is smart enough to classify errors and can even distinguish between errors that occured in your script from the ones that occured inside the framework.
  * <u>*RAICK.Settings.lua* file</u>
  This file is used to configure RAICK. See next section for more details.
  * <u>*RAICK.Uninstaller.bat* file</u>
  Run this file if you want to uninstall RAICK. All files that have been created during installation will be deleted.<br>
===<font color="#006600">AI Specific Files</font>===
  * <u>*Homunculus Script* folder</u>
  The structure of the folder is designed for maximum efficiency and convinience. Files are numbered to mimic the order, in which they are loaded upon startup of AI and also how they are processed later, when the client starts calling the script.
    * <u>*Logs & Errors* folder</u><br><br>
      * <u>*Error History.txt* file</u>
      This file is created(and later updated) when RAICK encounters an error inside your script. The entry will contain the time when the error occurep and a copy of the error window.
    * <u>*`[`0`]` Memory.lua* file</u>
    In this file RAICK stores values that you have decided to save. Saving data to a file is the only way to prevent it from being lost when the AI stops working(your homunculus/mercenary are not longer on the screen).
    * <u>*`[`1`]` On Startup.lua* file</u>
    In this file you define your custom variables or functions that you want to use in your script. This file is loaded once when the script starts. It is typical place for reading saved data from the memory or putting initial values to variables.
    * <u>*`[`2`]` Commands.lua* file</u>
    This is the place where you can define your own custom ways to interpet _Alt + Something_ commands that come from the player. Default handlers are auto-generated so you just have to modify them.
    * <u>*`[`3`]` Skills.lua* file</u>
    File with the same structure as the previous one, only here you can customize the way skill commands are interpreted by your AI.
    * <u>*`[`4`]` Messages.lua* file</u>
    In this file you can also define handlers like two previous ones, but they are meant to intercept messages that bots send to each other. This is a unique feature that allows sending arbitary data between homunculus and mercenary AI's.
    * <u>*`[`5`]` Activities.lua* file</u>
    The "heart" of your AI. Here you must define activities that you want your homunculus/mercenary to perform. Activities(also known as _states_ in most of AI's) is just a way to divide your script into logical parts. Each activity is a set of actions, which your logically group under some name. For example, the basic set of activities is:
      * _Passive_ - Don't react to anything. Just follow the owner.
      * _Active_ - If a monster is in sight then start chasing it(switch to _Chase_ activity), if not then follow owner.
      * _Chase_ - Chase the monster until you get close enough and then start attacking it(switch to _Attack_ activity).
      * _Attack_ - Attack the monster until it is killed or no longer in sight and then start looking for the next one(switch to _Active_ activity).
    Now, all you need to do is put these words into code and you have yourself a primitive AI.
  * <u>*Mercenary Script* folder</u>
  This folder basically mirrors the *Homunculus Script* folder. The only difference is that the *`[`3`]` Skills.lua* file is divided into separate parts, since mercenaries have a lot more targeted skills than homunculi do.<br><br>
----
==<font color="#006666">Settings</font>==
RAICK can be configured using the `RAICK.Settings.lua` file. Currently RAICK has 4 settings:
  * *VisionRange*
  <u>Default:</u> `14`<br>
  <u>Supported values:</u> `number >0`<br>

  The distance between your character and the visible edge of the screen(not the one you can see if you zoom out, but the one where objects, monsters etc are no longer visible). Typically it is 14 cells, but if you play on some unique server, then it might be different.
  * *Language*
  <u>Default:</u> `EN`<br>
  <u>Supported values:</u> `EN, RU`<br>

  Currently RAICK supports only English and Russian. This settings affects mainly error messages.
  * *LoggersUseTraceAI*
  <u>Default:</u> `NO`<br>
  <u>Supported values:</u> `YES, NO, ON, OFF`<br>

  Defines whether Logger objects react to */traceai* command status. This will be explained in the next chapter.
  * *BotCommunication*
  <u>Default:</u> `OFF`<br>
  <u>Supported values:</u> `YES, NO, ON, OFF`<br>

  Turns communication between homunculus and mercenary ON or OFF. This will be explained in the next chapter.
The names of settings and the values that they support are case insensitive, furthermore you can even separate different words with underscopes. For example:
  * visionrange
  * ViSion`___`RanGE
  * VISION`_`RANGE
  * VisionRange
Would all refer to the same setting. The same is with values:
  * Yes
  * No
  * On
  * Off
  * ON
  * OfF
Are all permitted. It does not matter if you write `'ON'` or `ON` inside this file, since variable names are translated into strings.<br>
And one more thing- if you omit/delete some setting the default value will be used. All of this is done for your convenience.<br><br>
----
==<font color="#006666">Try it out!</font>==
The best way to learn something in programming is by doing practical exercises or writing something yourself, so lets write a simple AI using RAICK. This way by the end of this chapter you will have both a working script and an idea whether RAICK actually suits your needs.<br><br>
----
===<font color="#006600">Some extra knowledge: Objects is RAICK</font>===
As much as would like to dig into the scripting process right away i can't leave this topic without attention, since roughly it is what RAICK is made of.<br>
From the chapter about Lua your know that an _object_ is a value, which is stored in a variable *by reference*. The same is true for RAICK objects(and pretty much for all objects in every modern programming language), but in the traditional meaning the _object_ is not only some value that stores its reference is a variable, but an advanced entity of data, which(unlike primitive values) can itself contain data and operations that work with this data. It can be seen as a way to group related data and actions that you can perform on this data under some general idea. Let me just explain this by comparing the way of Gravity with the way of RAICK:
<code language="lua">
-- This is a standard function from Gravity, which allows us to order the homunculus to go to a cell with (x,y) coordinates.
-- 'homunID' is the ID of your homunculus and (x,y) are coordinates of the destination cell.
Move(homunID, x, y)

-- Now lets observe how it is done in RAICK:
Homunculus.goTo(object)

-- Do you remember that i had mentioned something about the syntax 'something.something(arg1, arg2, ...)'?
-- Well, here it is. This is just a way to call inner functions of objects. Those functions are called "methods".
-- A method is like any other function, but the difference is that it is a "property" of the object and is linked with its data.

-- And one more pair:
Attack(homunID, targetID)

Homunculus.hit(target)
</code>

You can see that instead of writing a lot of separate functions that take their the ID as their first argument we can create a generalized concept- an object of type `Homunculus`. This object can be used to hold the data(like the type of your homunculus or its location) and the actions/commands associated with this data or with the concept itself(like methods to order your homunculus to move to some cell or use a skill). It is as almost we were saying:<br>
  _Homunculus, do that_<br>
Instead of:<br>
  _Function, make homunculus with this ID do that_<br>
This approach allows us to have a more organized, understandable and maintainable code and that is why objects are used in programming.<br>
So lets now sum up everything that we know about objects(as a general concept in programming):
  * Are values that are stored in variables as references
  * Are created using a special command/function(that can also take arguments as you will see later)
  * Can contain functions inside themselves(those functions are called _methods_ and in Lua they are just function values under string keys in a table)
  * Can contain any other type of data inside themselves(the places, where this data is stored are called _fields_ and in Lua they are just string keys in a table)
Let me also note that you need to understand the difference between the _object_ as a general concept in programming and those objects that exist in Lua. In Lua the word _object_ can mean either:
  * Just a value that stores its value in the variable by reference(for example, functions)
  * The implementation of the general concept using stuff that Lua has(for example, RAICK objects are designed using basically every data type available to fit the list features that this general concept declares)
There are actually a lot of other features that a true object should have, but i did not want to make them too complex, so they are sort of like a lightweight option.
<br><br>
----
===<font color="#006600">The initial idea</font>===
Now that RAICK objects is smaller mystery for us we can, finally, start thinking about our script. First of all, you need to have a clear idea of what you want from your AI. Every AI has a main purpose and this purpose defines the principles that you will use when creating it. Will it be for PvP or for mob killing only or maybe you would like to make a tank out of your homunculus/mercenary that would try to provoke monsters on itself. Of course, it is easy to say that: "I want it to be as cool as RampageAI!", but would not it be easier just to use Rampage instead? RAICK is not meant(but still can be used) to build super-complex AI's that do everything, because those AI's are already created and i don't think that you can make something even close to AzzyAI or RAIL, not speaking of writing a better one. Instead RAICK gives you, on the one hand, a way to get into the scripting process with less pain and, on the other hand, the possibility to write small scripts that 100% fulfill your needs. When your needs change, your script will change with them. This way you can initially write yourself a very simple script and modify it as your needs and your skills in programming will grow. Small, but constant changes to your script- that is the pattern i recommend following, when creating your AI using RAICK.<br>
So, going back to the idea. Lets create a script for homunculus Vanilmirth that would allow us to:
  * Give homunculus orders to attack a specified target using both Caprise and normal attacks
  * Auto-attack those who are damaging your character or homunculus and use caprise on those, who cast something on us(excluding support skills)
  * Switch between active and passive modes
Those 3 objectives now give us something to move further and start writing our first lines of code.<br><br>
----
===<font color="#006600">First lines of code</font>===
Lets move to our workplace- the `Homunculus AI` directory. Open the `On Startup` file. Here we can initialize(put initial values to) the variables that we are going to use. This is not entirely needed, but it allows us to eliminate the need to check our variables later in the code. Right now the only one we will need is the one, where we would store our target. So we write:
<code language="lua">
mainTarget = Actor()
-- 'Actor()' is a contructor for the object 'Actor', which represents all objects that your homunculus/mercenary can see(monsters, players, NPCs).
-- Normally, you would pass the ID of the object as an argument, but here we don't do it and as a result we get a "blank" Actor object.
-- The blank actor represents the absence of one, like 'nil' the absence of any value, but when the variable is meant to store actors ..
-- .. it is better to use this value instead of 'nil' as you will see later.
</code>

What we have done is we have put a blank actor as a default value for the target. It is the first/initial value that this variable will have when the script starts and it will signal that we have not got a target at the moment. If we did not do this then the default value would have been `nil`, which would force us to check this variable for `nil` every time we read it.<br>
The first step is made, lets now turn to the "main course"- the `Activities` file. As you can see one activity is already defined here. It serves mainly as an example. In this activity your homunculus would just follow you. This is certainly too simple for us so lets modify it.<br>
To begin we need at least 2 activities:
<code language="lua">
function    Main()

    Homun.goTo(Owner)
end

function    FollowOwner()

    Homun.goTo(Owner)
end
-- The 'Homun' variable holds the object of type Homunculus. As you might have already guessed it represents your homunculus.
-- In the auto-generated activity 'FollowOwner' the variable 'Homunculus' was used instead, which you can also use.
-- For your convenience references to this object are stored in variables starting from 'Hom' and ending with 'Homunculus'.
-- So, for example, 'Homu' or 'Homunc' can also be used.
</code>

Right now they are identical, but later we will start changing the first one.<br>
Before we do that we must provide ourselves with a way to switch between active(represented by activity `Main`) and passive(represented by activity `FollowOwner`) modes. This is done in the `Commands` file. You can see that this file is also filled with auto-generated functions. In programming those functions are called _handlers_, because they are meant to _handle_ certain signals that come from the outer or inner environment(in our case from the client) of your program. One of the methods to bind a handler function with the corresponding signal is by using predefined names and this is the method that RAICK uses:
<code language="lua">
-- When a function in this file is named 'AltT' or 'altt' or even 'ALT_T'(case and underscopes do not play any role), then RAICK binds it with the command 'Alt + T'.
function    AltT()

    if Activity.current.is.Main then -- If our current activity is 'Main', then ..
        Activity.switchTo.FollowOwner() -- .. we change it to 'FollowOwner'
    else -- If not, then ..
        Activity.switchTo.Main() -- .. we change it to 'Main'
    end
end
</code>

I think already from this short piece of code you can see how easy it is to use and understand RAICK. Let me explain i little bit what is happening here. What we do is we read the field `current` of the `Activity` object(which is located in the global variable `Activity`). This field contains another object of type `Value`. For now, all you need to know about this object is that it holds a name in form of a string and this string can be compared with some other string using a very convenient method `is`. That's right! It is a method, but not a regular one, since it allows you to write this:
<code language="lua">
something.is.name
</code>
Instead of:
<code language="lua">
something.is("name")
</code>

The first variant in definitely easier to read and faster to write. All RAICK objects have this method(and its opposite "twin brother" `isNot`) in common and later i will show you what other tricks can be performed using it.<br>
If we drop the technical details, then what `Activity.current.is.Main` does is it just gives us `true` if current activity is `Main`. Quite obvious, isn't it? Other lines are also pretty much self-explainable. The `switchTo` field contains a table, which holds functions that allow us to switch between activities.<br>
So, we can change modes now, but that doesn't give us anything without a target to attack, since passive mode is made mainly to stop homunculus/mercenary from attacking the target. We will deal with this issue in the next section.
<br><br>
----
===<font color="#006600">Target selection</font>===
There are many ways to tell your bot to attack something. If it doesn't have a targeted skill(for example, _Lif_ or _Amistr_), then basically the only choice you have is clicking near the target and ordering your bot to attack the closest one to this cell. Luckily, our _Vanilmirth_ has got _Caprise_ and we can use it directly to select targets.<br>
Lets do it then! Open `Skills` file. As always in RAICK handlers are already defined and default actions are set. What you need to do is redefine the handler for _Caprise_:
<code language="lua">
-- 'target' is an argument that this handler recieves.
-- This variable holds the 'Actor' object that represents the monster or player, on which you have used the skill 'Caprise'.
function    Caprise(target)

    mainTarget = target
end
</code>
Nothing to comment here.<br><br>
----
===<font color="#006600">Back to our activities</font>===
The preparational work is done, it is now time to think about how we are going to use the selected target. Obviously, we want to kill it. I propose that we make another activity just for this cause:
<code language="lua">
function    Main()

    if mainTarget.is.visible and mainTarget.action.isNot.dead then -- If the target is visible and not dead, then ..
        Activity.switchTo.AttackMainTarget() -- .. we lock on it to kill.
    else -- If not, then ..
        Homun.goTo(Owner) -- .. we just follow owner.
    end
end

function    AttackMainTarget()

    if mainTarget.isNot.visible or mainTarget.action.is.dead then -- If the target is not visible anymore or is already dead, then ..
        Activity.switchTo.Main() -- .. there is no point in performing this activity anymore and we can return to from where we came.
    else -- If the target is still with us, then ..
        -- 1) We follow it no matter what
        Homun.goTo(mainTarget)

        -- 2) Use 'Caprise', if we are in range of the skill
        if Homun .. mainTarget <= Caprise.range then
            Homun.use(Caprise).on(mainTarget)
        end

        -- 3) Hit/bite the target, if we close enough
        if Homun .. mainTarget <= Homun.hit.range then
            Homun.hit(mainTarget)
        end
    end
end

function    FollowOwner()

    Homun.goTo(Owner)
end
</code>

In the `Main` activity we check if the target is visible(can be visually observed on the screen) and if it is not dead(it might be confusing that being dead is an action, but you should just accept this for now), then we switch to our "killing activity".<br>
In the `AttackMainTarget` activity we check for the opposite: if the target is not visually observable or it is dead, then all is left for us is to go back to from where we came. The interesting part, though, starts when the target is still with us. 