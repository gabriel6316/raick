=<font color="#E07000">« Under construction »</font>=
<br>
=<font color="#003366">Reference Manual</font>=
A reference manual is a place, where the developer describes his creation in details. It is often a very dry and concrete document, reading which can be quite boring. You can check out the [http://www.lua.org/manual/5.1/manual.html Lua documentation] for an example of a typical reference manual.<br>
In this manual I'll try to keep a balance between technicality and lucidity of the content.
==<font color="#006666">Detailed Description of Objects</font>==
Objects are basically what RAICK is made of. About 80% of what the framework offers is in one way or another related to them. They are divided into 2 categories:
 * Single objects
 Exist only in one exemplar, which is automatically created upon startup of your script.
 * Multipliable objects
 Can be created multiple times using the _constructor_, which located in a global variable with the same name as the type of the object(for example, constructor for object `Cell` is located in the global variable `Cell`). The constructor is nothing more than a function and like every function it can take arguments(for example, `Cell(20,30)` creates a `Cell` object with coordinates (20,30)).<br>
Some objects allow operators to be used on them(you can distinguish them by the <u>*Operators*</u> subsection). For example, you may remember that we have used operator `..` to get the distance between your homunculus and its target in the [http://code.google.com/p/raick/wiki/GettingStarted#Back_to_Our_Activities Getting Started] guide.<br>
You may also notice that the <u>*Constructors*</u> subsection is in plural. That is because objects can indeed have multiple constructors. Every constructor takes different number or types of arguments and based on that produces an object with desired properties. A good example is the [http://code.google.com/p/raick/wiki/Manual#Logger Logger] object.<br>
The <u>*_is_ Methods*</u> subsection is used to describe what types and values does the _is_ group of methods understand for the current object. They are used to gain yes/no answers about the object. The group consists of 2 methods: `is` and `isNot`, which in turn have 2 forms, making a total of 4 methods. They can be described as follows:
  * `object.is(value1, value2, value3, ...)` - First form of `is` method
  * `object.is.value` - Second form of `is` method
  * `object.isNot(value1, value2, value3, ...)` - First form of `isNot` method
  * `object.isNot.value` - Second form of `isNot` method
The `object.isNot.value` method is just another way of writing `not object.is.value`. It is more readable, that's all. The first form of the `is`/`isNot` method can receive an arbitrary number of arguments of any type, but only certain values have meaning for it. The method returns `true` if all given values are "telling" the truth about the current object. If among those values is at least one value that the method cannot interpret(or which is "lying")  it will return `false`. The second form does the same, but can take only one `string` argument, which is passed to the method in a very original and convenient way. For example, `actor.is("visible")` is just another way of writing `actor.is.visible`. Although the second form is more restricted it is nonetheless faster to write and far easier to read and that's why i decided to introduce it. Last thing worth mentioning is that all string argument are case insensitive meaning that, for example, `actor.is("VISiBLe")` or `actor.is.ViSiBle` would also be accepted.<br>
Objects that are direct representations of the in-game objects of Ragnarok(actors, cell, your homunculus/mercenary, your character) have 2 special tables inside each of them. One is called `prev`, the other `last`. The first one is used to store information about the object from the previous call of the AI by the client(remember that the data changes only between those calls). The information in the second table changes only when the current data is changed. For example:
  * The script has started and the AI is called for the first time. The current cell of your character is (15,23). The previous cell is `nil` and the last cell is also `nil` since there is no previous data available.
  * The second call. Your character does not move. The current cell is (15,23). The previous cell is now also (15,23), since this is the value of the previous call, but the last cell remains `nil`, because the was no change in the value.
  * The third call. Your character has moved. The current cell is now (16,24). The previous cell remains (15,23), but the last cell changes to (15,23), since the current value has changed and we now know that the last cell, on which our character has stepped was (15,23).
===<font color="#006600">A Few Words About the Syntax</font>===
In the description below i use some syntactical aids to reduce the amount of unneeded repeating text making the manual more compact.<br>
For constructors, operators and object methods:
  * I use *<font color="#0052A3">blue</font>*.
  * After the :: i specify the return type of the constructor/method/operator. If the constructor/method/operator can return different types in different situations(for example, `nil` if something is wrong), then those types are separated with | .
For arguments and object fields:
  * I use *<font color="#5E5B00">dark yellow</font>* for optional arguments(the ones that you can omit when calling a function/method/constructor) and *<font color="#006666">cyan</font>* for mandatory arguments and object fields.
  * If the argument is optional, then i specify the default value(which is used if the argument is omitted) after the | .
  * After the :: i specify the type of the argument/field. If the argument/field can have/contain different types, then those types are separated with | . If the argument is supposed to have not only a certain type, but also i certain value(for example, > 0), then the restriction is specified inside ( ) next to the type.
<br>
----
===<font color="#006600">Multipliable Objects</font>===
====<font color="#660000">Value</font>====
The most primitive object in RAICK. It is used mainly to store the data about [http://code.google.com/p/raick/wiki/Manual#Actor actors]. Each object consists basically of a `number` and a `string`. In most cases the string is used to describe or translate the meaning of the number(ID), but you can also use the number, for example, to index the string or use only the string omitting the number. What i am saying is that it is just a `string`-`number` pair and it can be interpreted in many ways according to the place it is used in.<br>
Later in this guide i will specify `Value` objects in the following manner: `"string" (number1, number2, ...)`. For example:
    * `"Assassin" (12)` specifies a `Value` object with `"Assassin"` for a name and 12 for the number(ID).
    * `"Attacking" (2, 9)` specifies 2 `Value` objects, both having `"Attacking"` for a name and 2, 9 for the ID respectively.
In these examples i have specified `Value` objects that translate original ID's of a character type and an action type into human-readable strings and that is actually the main idea behind this object.
  * <u>*Constructors*</u><br><br>
    * *<font color="#0052A3">Value( <font color="#006666">name</font> , <font color="#5E5B00">id</font> )</font>* :: `Cell`<br><br>
      * *Arguments*<br><br>
        * <font color="#006666">*name*</font> :: `string`<br>
        Some name.<br>
        * <font color="#5E5B00">*id*</font> | `0` :: `number`<br>
        Some number, ID or index.<br>
      * *Description*
        Returns a `Value` object with given <font color="#006666">*name*</font> and <font color="#006666">*value*</font>.
  * <u>*Fields*</u><br><br>
      * <font color="#006666">*name*</font> :: `string`<br>
      The name of the value.<br>
      * <font color="#006666">*id*</font> :: `number`<br>
      The ID of the value.<br>
  * <u>*Regular Methods*</u><br>
    —<br>
  * <u>*_is_ Methods*</u><br><br>
    * *<font color="#0052A3">is( <font color="#006666">…</font> )</font>* , *<font color="#0052A3">isNot( <font color="#006666">…</font> )</font>* :: `boolean`<br><br>
      * *Accepted Types or Values*<br><br>
         * `Value` - Returns `true` if the given value is the same as the current.
         * `number` - Returns `true` if the `number` equals the <font color="#006666">*id*</font> of the current object.
         * `string` - Returns `true` if the `string` equals the <font color="#006666">*name*</font> of the current object.<br><br>
    * *<font color="#0052A3">is.<font color="#006666">value</font></font>* , *<font color="#0052A3">isNot.<font color="#006666">value</font></font>* :: `boolean`<br><br>
      * *Accepted Values*<br><br>
         * `string` - See previous method.
====<font color="#660000">Cell</font>====
Represents a cell with (x,y) coordinates on the current map/location. The coordinates of a cell, which your character is currently occupying can always be checked using the */where* command.
  * <u>*Constructors*</u><br><br>
    * *<font color="#0052A3">Cell( <font color="#006666">x</font> , <font color="#006666">y</font> )</font>* :: `Cell`<br><br>
      * *Arguments*<br><br>
        * <font color="#006666">*x*</font> :: `number` ( > 0 )<br>
        The X-coordinate of the cell.<br>
        * <font color="#006666">*y*</font> :: `number` ( > 0 )<br>
        The Y-coordinate of the cell.<br>
      * *Description*
        Returns a `Cell` object with (<font color="#006666">*x*</font>, <font color="#006666">*y*</font>) coordinates.
  * <u>*Fields*</u><br><br>
      * <font color="#006666">*x*</font> :: `number`<br>
      The X-coordinate of the cell.<br>
      * <font color="#006666">*y*</font> :: `number`<br>
      The Y-coordinate of the cell.<br>
      * <font color="#006666">*occupier*</font> :: `Actor` | `Owner` | `Homunculus` | `Mercenary` | `nil`<br>
      The "live" object, which is currently standing on the cell. Contains `nil` if the cell is empty. In case on multiple occupiers contains only one of them.<br>
  * <u>*Regular Methods*</u><br>
    —<br>
  * <u>*_is_ Methods*</u><br><br>
    * *<font color="#0052A3">is( <font color="#006666">…</font> )</font>* , *<font color="#0052A3">isNot( <font color="#006666">…</font> )</font>* :: `boolean`<br><br>
      * *Accepted Types or Values*<br><br>
         * `Cell` - Returns `true` if the given cell is the same as the current.
         * `"visible"` - Returns `true` if the current cell is in range of sight of your character.
         * `"occupied"` - Returns `true` if the current cell is occupied by some actor.
         * `"x;y"` - Returns `true` if the current cell has specified (x,y) coordinates. The delimiter ; can be replaced with anything you want as long as it is not a number.  For example `"23;45"`, `"23|45"`.<br><br>
    * *<font color="#0052A3">is.<font color="#006666">value</font></font>* , *<font color="#0052A3">isNot.<font color="#006666">value</font></font>* :: `boolean`<br><br>
      * *Accepted Values*<br><br>
         * `visible` - See previous method.
         * `occupied` - See previous method.
  * <u>*Operators*</u><br><br>
    * *<font color="#0052A3"><font color="#006666">cell</font> + <font color="#006666">vector</font> `*` <font color="#5E5B00">distance</font></font>* :: `Cell`<br><br>
      * *Arguments*<br><br>
        * <font color="#006666">*cell*</font> :: `Cell`<br>
        An arbitrary `Cell` object.<br>
        * <font color="#006666">*vector*</font> :: `Vector`<br>
        An arbitrary `Vector` object.<br>
        * <font color="#5E5B00">*distance*</font> | `1` :: _number_<br>
        The distance, by which the *<font color="#006666">cell</font>* will be shifted in the direction of *<font color="#006666">vector</font>*. Negative values will shift it in the opposite direction.<br>
      * *Description*
        This equation returns the cell, which is *<font color="#5E5B00">distance</font>* cells away from the *<font color="#006666">cell</font>* in the direction defined by *<font color="#006666">vector</font>*.
    * *<font color="#0052A3"><font color="#006666">cell</font> .. <font color="#006666">object</font></font>* :: `number` | `nil`<br><br>
      * *Arguments*<br><br>
        * <font color="#006666">*cell*</font> :: `Cell`<br>
        An arbitrary `Cell` object.<br>
        * <font color="#006666">*object*</font> :: `Cell` | `Actor` | `Owner` |  `Homunculus` |  `Mercenary`<br>
        Any in-game object, distance till which you want to know.<br>
      * *Description*
        Returns the distance(in cells) between <font color="#006666">*cell*</font> and <font color="#006666">*object*</font> or `nil` if <font color="#006666">*object*</font> is not visible.
====<font color="#660000">Actor</font>====
Represents an in-game character(monster, NPC or player character), which can be distinguished by its' unique ID. `Owner`, `Homunculus` and `Mercenary` objects can also be called actors, but they are allocated into separate object, since they are _special_ actors meaning that you can get more data about them and send commands to some of them.
  * <u>*Constructors*</u><br><br>
    * *<font color="#0052A3">Actor( <font color="#5E5B00">id</font> )</font>* :: `Actor`<br><br>
      * *Arguments*<br><br>
        * <font color="#5E5B00">*id*</font> | `0` :: `number` ( >= 0 )<br>
        ID of the actor.<br>
      * *Description*
        Returns an _Actor_ object, which represent an in-game character with given ID.
  * <u>*Fields*</u><br><br>
      * <font color="#006666">*id*</font> :: `number`<br>
      Actors' ID.<br>
      * <font color="#006666">*status*</font> :: `Value`<br>
      Actors' current visibility status. Can be one of the following:<br><br>
        * `"Unknown" (0)` - The actor is outside of the vision range and the AI cannot get any data about it.
        * `"Hidden" (1)` - The actor is inside the vision range, but it is visually hidden(_Hiding_, _Clocking_ etc), which means that the AI cannot get its' location.
        * `"Visible" (2)` - The actor is visually observable.<br>
      * <font color="#006666">*prev.status*</font> :: `Value`<br>
      Actors' previous visibility status.<br>
      * <font color="#006666">*last.status*</font> :: `Value`<br>
      Actors' previous last status.<br>
      * <font color="#006666">*cell*</font> :: `Cell`<br>
      Actors' current cell.<br>
      * <font color="#006666">*prev.cell*</font> :: `Cell`<br>
      Actors' previous cell.<br>
      * <font color="#006666">*last.cell*</font> :: `Cell`<br>
      Actors' last cell.<br>
      * <font color="#006666">*action*</font> :: `Value`<br>
      Actors' current action. Can be one of the following:<br><br>
        * `"Standing" (0)` - The actor is standing.
        * `"Moving" (1)` - The actor is moving.
        * `"Attacking" (2, 9)` - The actor is attacking.
        * `"Dead" (3)` - The actor is dead.
        * `"Damaged" (4)` - The actor is being damaged.
        * `"Bending" (5)` - The actor is bending to place something on the ground or to pick something up.
        * `"Sitting" (6)` - The actor is sitting.
        * `"Casted" (7, 20, 21, 22, 23, 24, 26, 30, 31, 32, 33, 34, 35, 36, 38, 39, 40)` - The actor has casted/used a skill.
        * `"Casting" (8, 13, 18, 19, 28, 37, 41, 42)` - The actor is casting a skill.
        * `"Throwing" (12)` - The actor is throwing something.
        * `"Dancing" (16)` - The actor is dancing.
        * `"Performing" (17)` - The actor is performing a song.
      * <font color="#006666">*prev.action*</font> :: `Value`<br>
      Actors' previous action.
      * <font color="#006666">*last.action*</font> :: `Value`<br>
      Actors' last action.
  * <u>*Regular Methods*</u><br><br>
    —<br>
  * <u>*_is_ Methods*</u><br><br>
    * *<font color="#0052A3">is( <font color="#006666">…</font> )</font>* , *<font color="#0052A3">isNot( <font color="#006666">…</font> )</font>* :: `boolean`<br><br>
      * *Accepted Types or Values*<br><br>
         * `Actor` - Returns `true` if the given actor is the same as the current.
         * `number` - Returns `true` if the current actor has the same ID.
         * Numeric `string` - Returns `true` if the current actor has the same ID.
         * `"player"` - Returns `true` if the current actor is a player character.<br><br>
    * *<font color="#0052A3">is.<font color="#006666">value</font></font>* , *<font color="#0052A3">isNot.<font color="#006666">value</font></font>* :: `boolean`<br><br>
      * *Accepted Values*<br><br>
         * `player` - See previous method.
  * <u>*Operators*</u><br><br>
    * *<font color="#0052A3"><font color="#006666">actor</font> .. <font color="#006666">object</font></font>* :: `number` | `nil`<br><br>
      * *Arguments*<br><br>
        * <font color="#006666">*actor*</font> :: `Actor`<br>
        An arbitrary `Actor` object.<br>
        * <font color="#006666">*object*</font> :: `Cell` | `Actor` | `Owner` |  `Homunculus` |  `Mercenary`<br>
        Any in-game object, distance till which you want to know.<br>
      * *Description*
        Returns the distance(in cells) between <font color="#006666">*actor*</font> and <font color="#006666">*object*</font> or `nil` if at least one of them is not visible.
====<font color="#660000">Points</font>====
====<font color="#660000">Skill</font>====
====<font color="#660000">List</font>====
====<font color="#660000">Map</font>====
====<font color="#660000">Timer</font>====
====<font color="#660000">Logger</font>====
====<font color="#660000">Vector</font>====
===<font color="#006600">Single Objects</font>===
====<font color="#660000">Homunculus</font>====
====<font color="#660000">Mercenary</font>====
====<font color="#660000">Memory</font>====
==<font color="#006666">Detailed Overview of Files</font>==
==<font color="#006666">Understanding RAICK Errors</font>==
==<font color="#006666">Data Exchange Between Homunculus and Mercenary</font>==